集合类的由来：
	对象用于封装特有数据，对象多了需要存储，如果对象的个数不确定。
	就使用集合容器进行存储
	
集合特点：
1，用于存储对象的容器
2，集合的长度可变
3，集合中不可以存储基本数据类型

集合容器因为内部的数据结构不同，有多种具体容器
不断的向上抽取，就形成了集合框架

框架的顶层Collection接口：

1，添加
	boolean	add(Object obj)
	boolean	addAll(Collection coll)

2，删除
	boolean remove(Object obj)
	boolean removeAll(Collection coll)
	void clear()：清空集合中的元素

3，判断
	boolean contains(Object obj)
	boolean	containsAll(Collection coll)	

	boolean isImpty()：判断集合中是否有元素
4，获取
	int size()
	Iterator iterator()：	取出元素的方式：迭代器
	该对象必须依赖于具体容器，因为每一个容器的数据结构不同。
	所以该迭代器对象是在容器中进行内部实现的
	对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法
	
	Iterator接口就是对所有的Collection容器进行元素取出的公共接口
5，其他
	boolean	retainAll(Collection coll)：	取交集
	Object[] toArray()：将集合转成数组
	
----------------------------------------------------------------------------------------------------------------------------------------------------------

Coolection
	|--List：有序（存入和取出的顺序一致），元素都有索引（角标），可以重复
	|--Set：元素不能重复
	
	
List：特有的常见方法：有一个共性特点就是都可以操作角标。
1，添加
	void add(index, element)
	void add(index, collection)
2，删除
	Object remove(index)
3，修改
	Object set(index, element)
4，获取
	Object get(index)
	int indexOf(object)
	int lastIndexOf(object)
	List sublist(from, to)

list集合是可以完成对元素的增删改查。


List：
	|--Vector：内部是数组数据结构，是同步。增删，查询都很慢！！！
	|--ArrayList：内部是数组数据结构，是不同步，替代了Vector。查询速度快
	|--LinkedList：内部是链表数据结构，是不同步的。增删元素的速度很快。
	
LinkedList：
	
	addFirst();
	addLast();
	jdk1.6
	offerFirst();
	offerLast();
	
	getFirst();//获取但不移除，如果链表为空，抛出NoSuchElementExecption
	getLast();
	jdk1.6
	peekFirst();//获取但不移除，如果链表为空，返回null
	peekLast();
	
	removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementExecption
	removeLast();
	jdk1.6	
	pollFirst();//获取并移除，如果链表为空，返回null
	pollLast();
	
	
-------------------------------------------------------------------------------------------------------------


Set：元素不可以重复，是无序
	Set接口中的方法和Collection一致
	|--HashSet：内部数据结构是哈希表，是不同步的。
	如何保证该集合的元素唯一性呢？
	是通过对象的hashCode和equals方法来完成对象唯一性的。
	如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。
	如果对象的hashCode值相同，那么要再次判断对象的euqals方法是否为true.
	如果为true，视为相同元素，不存在。如果为false，那么视为不同元素，就进行存储。
	
	记住：如果元素要存储到HashSet集合中，必须覆盖hashCode方法和equals。
	一般情况下，如果定义的类会产生很多对象，比如人，学生，书，通常都需要覆盖equals，hashCode方法，建立对象判断是否相同的依据。
	
	|--TreeSet：可以对Set集合中的元素进行排序，是不同步的。
	判断元素唯一性的方式：根据比较方法的返回结果是否是0，是0，就是相同元素，不存。
	
	TreeSet对元素进行排序的方式一：
	让元素自身具备比较功能，元素就需要实现Comparable接口，覆盖coppareTo方法。
	
	如果不需要按照对象中具备的自然顺序进行排序，如果对象中不具备自然顺序，怎么办？
	可以使用TreeSet集合第二种排序方式二：
	让集合自身具备比较功能，定义一个类实现Comparator接口，覆盖compare方法。
	将该类对象作为参数传递给TreeSet集合的构造 函数。
	
	
--------------------------------------------------------------------------------------------------------------	
	

List：
	|--ArrayList
	|--linkedList
	
Set：
	|--HashSet
	|--TreeSet
	
后缀名就是该集合所属的体系。
前缀名就是该集合的数据结构。

看到array：就要想到数组，就要想到查询快，有角标。
看到link：就要想到链表，就要想到增删快，就要想到add，get，remove first + last方法。
看到hash：就要想到hash表，就要想到唯一性，就要想到元素需要覆盖hashCode和equals方法。
看到tree：就要想到二叉树，就要想到排序，就要想到两个接口Comparable和Comparator。

而且通常这些常用的集合容器都是不同步的。




----------------------------------------------------------------------------------------------------------------



Map：一次添加一对元素。Collection一次添加一个元素。
	Map集合称为双列集合，Collection称为单列集合。
	其实Map集合存储的是键值对。
	Map集合中必须保证键的唯一性。
	
常用方法：
1，添加
	value put(key, value)： 返回前一个和key关联的值，如果没有返回null。
	
2，删除
	void clear()	清空集合
	value remove(key)	根据指定的key删除这个键值对
	
3，判断
	boolean containsKey(key)
	boolean containsValue(value)
	boolean isEmpty()

4，获取
	value get(key)	通过键获取值，如果没有该键返回null。
					可以通过返回null，来判断是否包含指定键。
	int size()	返回键值对的个数。


Map常用子类：
	|--HashTable：内部结构是哈希表，是同步的。不允许null作为键，null作为值。
		|--properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。
	|--HashMap：内部结构是哈希表，不是同步的。允许null作为键，null作为值。
	|--TreeMap：内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。
	


------------------------------------------------------------------------------------------------------------------


泛型：
	jdk1.5出现的安全机制。
好处：
	1，将运行时期的问题classCastException转到了编译时期。
	2，避免了强制类型转换的麻烦。
	
<>	什么时候用？
	当操作的引用数据类型不确定的时候，就使用<>。将要操作的引用数据类型传入即可。其实<>就是一个用于接收具体引用数据类型的参数范围。
	在程序中，只要用到了带有<>的类或者接口，就要明确传入的具体引用数据类型。

泛型技术是给编译器使用的技术，用于编译时期，确保了类型的安全。

运行时，会将泛型去掉，生成的class文件中是不带泛型的，这个称为泛型的擦除。
为什么擦除呢？因为为了兼容运行的类加载器。

泛型的补偿：在运行时，通过获取元素的类型进行转换动作，不用使用者再进行强制转换了。

泛型的通配符：？未知类型。
